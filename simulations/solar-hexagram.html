<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>IQS-888 â€” Solar System in Hexagram Space-Time</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #06060f; color: #d4c8a8;
  font-family: 'Courier New', monospace; overflow: hidden;
}
canvas#cosmos { position: fixed; top: 0; left: 0; z-index: 0; }

/* â•â•â• Right Panel â•â•â• */
#panel {
  position: fixed; right: 0; top: 0; width: 320px; height: 100vh;
  background: rgba(6,6,15,0.92); border-left: 1px solid #2a2a3a;
  padding: 16px; overflow-y: auto; z-index: 10;
  font-size: 11px; line-height: 1.6;
}
#panel h2 { color: #c9a96e; font-size: 14px; margin-bottom: 8px; letter-spacing: 2px; }
#panel h3 { color: #8a7a5a; font-size: 11px; margin: 12px 0 4px; text-transform: uppercase; letter-spacing: 1px; }
.hex-display {
  display: flex; align-items: center; gap: 12px;
  margin: 8px 0; padding: 8px; background: rgba(40,35,25,0.5);
  border: 1px solid #2a2a1a; border-radius: 4px;
}
.hex-lines { display: flex; flex-direction: column; gap: 2px; }
.hex-line {
  width: 32px; height: 4px; border-radius: 1px;
}
.hex-line.yang { background: #c9a96e; }
.hex-line.yin {
  background: transparent;
  border-left: 12px solid #c9a96e;
  border-right: 12px solid #c9a96e;
  width: 32px;
}
.hex-name { color: #e0d8c8; font-size: 13px; }
.hex-number { color: #6a6a5a; font-size: 10px; }

.stat-row { display: flex; justify-content: space-between; padding: 2px 0; }
.stat-label { color: #6a6a5a; }
.stat-value { color: #c9a96e; font-weight: bold; }

.fourier-bar {
  height: 6px; border-radius: 2px; margin: 2px 0;
  transition: width 0.3s;
}
.energy-section { margin-top: 12px; padding: 8px; background: rgba(60,40,20,0.3); border-radius: 4px; }
.energy-total { font-size: 16px; color: #ffd700; text-align: center; margin: 4px 0; }

/* â•â•â• Controls â•â•â• */
#controls {
  position: fixed; bottom: 16px; left: 50%; transform: translateX(-50%);
  display: flex; gap: 12px; align-items: center; z-index: 10;
  background: rgba(6,6,15,0.85); padding: 8px 20px;
  border: 1px solid #2a2a3a; border-radius: 20px;
}
#controls button {
  background: none; border: 1px solid #4a4a3a; color: #c9a96e;
  padding: 4px 12px; border-radius: 4px; cursor: pointer;
  font-family: inherit; font-size: 11px;
}
#controls button:hover { background: rgba(201,169,110,0.15); }
#controls button.active { background: rgba(201,169,110,0.3); border-color: #c9a96e; }
#controls label { color: #6a6a5a; font-size: 10px; }
#controls input[type=range] { width: 100px; accent-color: #c9a96e; }

/* â•â•â• Title â•â•â• */
#title {
  position: fixed; top: 16px; left: 16px; z-index: 10;
  font-size: 10px; color: #4a4a3a; letter-spacing: 2px;
}
#title span { color: #c9a96e; }

/* â•â•â• Wheel â•â•â• */
canvas#wheel {
  position: fixed; left: 16px; bottom: 60px; z-index: 10;
  border-radius: 50%; background: rgba(6,6,15,0.7);
}

/* â•â•â• Resonance Matrix â•â•â• */
#resonance {
  position: fixed; left: 16px; top: 50px; z-index: 10;
  font-size: 9px; background: rgba(6,6,15,0.8); padding: 8px;
  border: 1px solid #1a1a2a; border-radius: 4px;
  display: none;
}
</style>
</head>
<body>

<canvas id="cosmos"></canvas>
<canvas id="wheel" width="180" height="180"></canvas>

<div id="title">
  <span>IQS-888</span> SOLAR SYSTEM IN HEXAGRAM SPACE-TIME<br>
  E = mc&sup2; &times; 64 &nbsp;|&nbsp; c = 64 &nbsp;|&nbsp; Operations are lookup tables
</div>

<div id="panel">
  <h2>&#9776; HEXAGRAM STATE</h2>
  <div id="body-info"></div>
</div>

<div id="controls">
  <button id="btn-pause">&#9646;&#9646;</button>
  <label>Speed</label>
  <input type="range" id="speed" min="0.1" max="20" step="0.1" value="2">
  <label>Zoom</label>
  <input type="range" id="zoom" min="0.5" max="8" step="0.1" value="2.5">
  <button id="btn-field">Field</button>
  <button id="btn-waves">Waves</button>
  <button id="btn-trails">Trails</button>
  <button id="btn-res">Resonance</button>
</div>

<div id="resonance"></div>

<script>
'use strict';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  IQS-888 SOLAR SYSTEM â€” GRAVITATIONAL FIELDS IN HEXAGRAM
//  SPACE-TIME
//
//  "Operations are simple lookup tables, in a graphical interface
//   with infinite nodes across, you can represent any piece of
//   information with low dimensionality and automatically know
//   its position in the hyperspace"
//                                         â€” The Philosopher
//
//  E = mcÂ² Ã— 64   |   c = 64 hexagrams/cycle
//  Three Fourier coordinates: (Î½, A, Ï†)
//  Gravity modulated by hexagram resonance
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â• CONSTANTS â•â•â•
const G    = 4 * Math.PI * Math.PI;  // GÂ·Mâ˜‰ in AUÂ³/yrÂ²
const C_HEX = 64;                     // Speed of light in hexagram space
const TAU  = 2 * Math.PI;

// â•â•â• TRIGRAMS (Fu Xi binary: bottom line = MSB) â•â•â•
const TRI = [
  { bin: 0, name: 'Earth',    sym: 'â˜·', elem: 'ğŸœ‚', nature: 'receptive' },
  { bin: 1, name: 'Mountain', sym: 'â˜¶', elem: 'ğŸœ‚', nature: 'still'     },
  { bin: 2, name: 'Water',    sym: 'â˜µ', elem: 'ğŸœƒ', nature: 'deep'      },
  { bin: 3, name: 'Wind',     sym: 'â˜´', elem: 'ğŸœ„', nature: 'gentle'    },
  { bin: 4, name: 'Thunder',  sym: 'â˜³', elem: 'ğŸœ„', nature: 'arousing'  },
  { bin: 5, name: 'Fire',     sym: 'â˜²', elem: 'ğŸœ', nature: 'clinging'  },
  { bin: 6, name: 'Lake',     sym: 'â˜±', elem: 'ğŸœ', nature: 'joyous'    },
  { bin: 7, name: 'Heaven',   sym: 'â˜°', elem: 'ğŸœ', nature: 'creative'  },
];

// â•â•â• HEXAGRAM RESONANCE â•â•â•
// The lookup table that replaces computation.
// Resonance between two hexagrams modulates gravitational coupling.
function hexResonance(bin1, bin2) {
  if (bin1 === bin2) return 1.3; // perfect resonance
  const diff = bin1 ^ bin2;
  let matching = 0;
  for (let i = 0; i < 6; i++) if (!((diff >> i) & 1)) matching++;

  // Nuclear hexagram: inner 4 lines (bits 1-4)
  const nuc1 = (bin1 >> 1) & 0xF;
  const nuc2 = (bin2 >> 1) & 0xF;
  const nucBonus = nuc1 === nuc2 ? 0.08 : 0;

  // Complement pair (all bits flipped = MÃ¶bius resonance)
  const complement = diff === 63 ? 0.12 : 0;

  // Shared lower trigram (foundation)
  const sharedLower = ((bin1 >> 3) === (bin2 >> 3)) ? 0.06 : 0;
  // Shared upper trigram (expression)
  const sharedUpper = ((bin1 & 7) === (bin2 & 7)) ? 0.04 : 0;

  return 0.82 + (matching / 6) * 0.32 + nucBonus + complement + sharedLower + sharedUpper;
}

// â•â•â• CELESTIAL BODIES â•â•â•
// Each body: hexagram identity, real orbital parameters, Fourier state
const BODY_DEFS = [
  // name, symbol, hex King Wen #, hex binary (Fu Xi), hex name,
  // mass (Mâ˜‰), semi-major axis (AU), eccentricity, color, radius (px)
  { name: 'Sun',     sym: 'â˜‰', kwn: 1,  bin: 63, hexName: 'The Creative',       mass: 1.0,      a: 0,     e: 0,     color: '#FFD700', r: 18, desc: 'Pure yang â€” generative source' },
  { name: 'Mercury', sym: 'â˜¿', kwn: 31, bin: 14, hexName: 'Influence',           mass: 1.66e-7,  a: 0.387, e: 0.206, color: '#B8B8B8', r: 3,  desc: 'Swift messenger â€” quick influence' },
  { name: 'Venus',   sym: 'â™€', kwn: 58, bin: 54, hexName: 'The Joyous',          mass: 2.45e-6,  a: 0.723, e: 0.007, color: '#F5DEB3', r: 5,  desc: 'Beauty, attraction, harmony' },
  { name: 'Earth',   sym: 'ğŸœ‚', kwn: 11, bin: 56, hexName: 'Peace',               mass: 3.00e-6,  a: 1.000, e: 0.017, color: '#4488CC', r: 5,  desc: 'Heaven under Earth â€” perfect balance' },
  { name: 'Mars',    sym: 'â™‚', kwn: 34, bin: 60, hexName: 'Great Power',          mass: 3.23e-7,  a: 1.524, e: 0.093, color: '#CC5544', r: 4,  desc: 'Thunder over Heaven â€” martial force' },
  { name: 'Jupiter', sym: 'â™ƒ', kwn: 14, bin: 61, hexName: 'Great Possession',     mass: 9.55e-4,  a: 5.203, e: 0.048, color: '#DEB887', r: 10, desc: 'Fire over Heaven â€” abundance' },
  { name: 'Saturn',  sym: 'â™„', kwn: 52, bin: 9,  hexName: 'Keeping Still',        mass: 2.86e-4,  a: 9.537, e: 0.054, color: '#D2C07A', r: 8,  desc: 'Mountain over Mountain â€” structure' },
  { name: 'Uranus',  sym: 'â™…', kwn: 51, bin: 36, hexName: 'The Arousing',         mass: 4.37e-5,  a: 19.19, e: 0.047, color: '#87CEEB', r: 6,  desc: 'Thunder over Thunder â€” revolution' },
  { name: 'Neptune', sym: 'â™†', kwn: 29, bin: 18, hexName: 'The Abysmal',          mass: 5.15e-5,  a: 30.07, e: 0.009, color: '#4169E1', r: 6,  desc: 'Water over Water â€” depth, mystery' },
  { name: 'Pluto',   sym: 'â™‡', kwn: 23, bin: 1,  hexName: 'Splitting Apart',      mass: 6.55e-9,  a: 39.48, e: 0.249, color: '#C9A06A', r: 2,  desc: 'Mountain over Earth â€” transformation' },
];

// â•â•â• STATE â•â•â•
let bodies = [];
let trails = [];        // orbital trails per body
let wavefronts = [];    // gravitational wave ripples
let time = 0;
let dt = 0.0005;        // years per physics step
let paused = false;
let speed = 2;
let zoom = 2.5;
let selectedIdx = 3;    // Earth selected by default
let showField = false;
let showWaves = true;
let showTrails = true;
let showResonance = false;
let fieldCanvas, fieldCtx;

// â•â•â• INITIALIZE BODIES â•â•â•
function initBodies() {
  bodies = [];
  trails = [];
  wavefronts = [];
  time = 0;

  // Spread planets at different initial angles for visual variety
  const initAngles = [0, 0, Math.PI/3, 2*Math.PI/3, Math.PI, 5*Math.PI/3, Math.PI/6, Math.PI/2, 4*Math.PI/3, 5*Math.PI/6];

  BODY_DEFS.forEach((def, i) => {
    const theta = initAngles[i] || 0;
    let x = 0, y = 0, vx = 0, vy = 0;

    if (def.a > 0) {
      // Place at distance a (circular orbit approximation)
      const r = def.a;
      x = r * Math.cos(theta);
      y = r * Math.sin(theta);
      // Circular orbit velocity: v = sqrt(GM/r) = 2Ï€/sqrt(a)
      const v = TAU / Math.sqrt(def.a);
      vx = -v * Math.sin(theta);
      vy =  v * Math.cos(theta);
    }

    bodies.push({
      ...def, x, y, vx, vy, ax: 0, ay: 0,
      // Fourier state (computed each frame)
      fourier: { nu: 0, amp: 0, phase: 0, harmonics: [] },
      // Energy
      energy: { kinetic: 0, potential: 0, hexagram: 0, total: 0 },
      // Angular momentum
      L: 0,
    });

    trails.push([]);
  });
}

// â•â•â• PHYSICS: N-BODY GRAVITY WITH HEXAGRAM RESONANCE â•â•â•
function computeAccelerations() {
  for (let i = 0; i < bodies.length; i++) {
    bodies[i].ax = 0;
    bodies[i].ay = 0;
  }

  for (let i = 0; i < bodies.length; i++) {
    for (let j = i + 1; j < bodies.length; j++) {
      const bi = bodies[i], bj = bodies[j];
      const dx = bj.x - bi.x;
      const dy = bj.y - bi.y;
      const r2 = dx * dx + dy * dy;
      const r = Math.sqrt(r2);

      if (r < 0.001) continue; // softening

      // Hexagram resonance modulates the gravitational constant
      const resonance = hexResonance(bi.bin, bj.bin);

      // F = G * mi * mj * resonance / rÂ²
      // a_i = G * mj * resonance / rÂ² * (r_hat)
      const accel = G * resonance / (r2 * r); // common factor / rÂ³

      bi.ax += accel * bj.mass * dx;
      bi.ay += accel * bj.mass * dy;
      bj.ax -= accel * bi.mass * dx;
      bj.ay -= accel * bi.mass * dy;
    }
  }
}

// Velocity Verlet integrator (symplectic, energy-conserving)
function step() {
  const stepsPerFrame = Math.max(1, Math.round(speed * 4));

  for (let s = 0; s < stepsPerFrame; s++) {
    // Half-step velocity
    for (let i = 0; i < bodies.length; i++) {
      bodies[i].vx += 0.5 * dt * bodies[i].ax;
      bodies[i].vy += 0.5 * dt * bodies[i].ay;
    }
    // Full-step position
    for (let i = 0; i < bodies.length; i++) {
      bodies[i].x += dt * bodies[i].vx;
      bodies[i].y += dt * bodies[i].vy;
    }
    // Recompute accelerations
    computeAccelerations();
    // Half-step velocity
    for (let i = 0; i < bodies.length; i++) {
      bodies[i].vx += 0.5 * dt * bodies[i].ax;
      bodies[i].vy += 0.5 * dt * bodies[i].ay;
    }

    time += dt;
  }
}

// â•â•â• FOURIER ENCODING â•â•â•
// Decompose current state into (frequency, amplitude, phase)
function updateFourier() {
  for (let i = 1; i < bodies.length; i++) { // skip sun
    const b = bodies[i];
    const r = Math.sqrt(b.x * b.x + b.y * b.y);
    const v = Math.sqrt(b.vx * b.vx + b.vy * b.vy);
    const theta = Math.atan2(b.y, b.x);

    // Fundamental orbital frequency
    const T = (b.a > 0) ? Math.pow(b.a, 1.5) : 1; // Kepler T = a^(3/2)
    const nu = 1.0 / T; // frequency in cycles/year

    b.fourier.nu = nu;
    b.fourier.amp = r;
    b.fourier.phase = ((theta % TAU) + TAU) % TAU; // 0 to 2Ï€

    // Harmonic decomposition (first 6 harmonics from current state)
    b.fourier.harmonics = [];
    for (let h = 1; h <= 6; h++) {
      // Each harmonic's amplitude decays roughly as eccentricity^h
      const hAmp = r * Math.pow(b.e || 0.01, h - 1);
      const hPhase = (h * theta) % TAU;
      b.fourier.harmonics.push({ n: h, amp: hAmp, phase: hPhase });
    }

    // Angular momentum L = r Ã— v (2D cross product)
    b.L = b.x * b.vy - b.y * b.vx;
  }
}

// â•â•â• ENERGY: E = mcÂ² Ã— 64 â•â•â•
function updateEnergy() {
  for (let i = 0; i < bodies.length; i++) {
    const b = bodies[i];
    const v2 = b.vx * b.vx + b.vy * b.vy;

    // Kinetic energy: Â½mvÂ²
    b.energy.kinetic = 0.5 * b.mass * v2;

    // Rest energy: E = mcÂ² where c = 64
    b.energy.hexagram = b.mass * C_HEX * C_HEX; // mcÂ² Ã— (implicit Ã—1, c=64)

    // Gravitational potential energy (sum of pairs)
    let pe = 0;
    for (let j = 0; j < bodies.length; j++) {
      if (i === j) continue;
      const dx = bodies[j].x - b.x;
      const dy = bodies[j].y - b.y;
      const r = Math.sqrt(dx * dx + dy * dy);
      if (r > 0.001) {
        pe -= G * b.mass * bodies[j].mass * hexResonance(b.bin, bodies[j].bin) / r;
      }
    }
    b.energy.potential = pe;

    // Total: kinetic + potential + rest (hexagram)
    b.energy.total = b.energy.kinetic + b.energy.potential + b.energy.hexagram;
  }
}

// â•â•â• GRAVITATIONAL WAVEFRONTS â•â•â•
let waveTimer = 0;
function emitWaves() {
  waveTimer++;
  if (waveTimer % 30 !== 0) return; // emit every 30 frames

  for (let i = 1; i < Math.min(bodies.length, 7); i++) { // inner planets + Jupiter
    const b = bodies[i];
    wavefronts.push({
      x: b.x, y: b.y,
      radius: 0,
      color: b.color,
      maxRadius: 15, // AU
      speed: C_HEX * dt * 4, // propagation speed (scaled for visibility)
    });
  }

  // Prune old wavefronts
  wavefronts = wavefronts.filter(w => w.radius < w.maxRadius);
}

// â•â•â• CANVAS SETUP (HiDPI / Retina stabilized) â•â•â•
const cosmos = document.getElementById('cosmos');
const ctx = cosmos.getContext('2d');
const wheelCanvas = document.getElementById('wheel');
const wheelCtx = wheelCanvas.getContext('2d');
const DPR = window.devicePixelRatio || 1;

function setupHiDPI(canvas, context, cssW, cssH) {
  canvas.width = cssW * DPR;
  canvas.height = cssH * DPR;
  canvas.style.width = cssW + 'px';
  canvas.style.height = cssH + 'px';
  context.setTransform(DPR, 0, 0, DPR, 0, 0);
  context.imageSmoothingEnabled = true;
  context.imageSmoothingQuality = 'high';
}

function resize() {
  const w = window.innerWidth;
  const h = window.innerHeight;
  setupHiDPI(cosmos, ctx, w, h);
  setupHiDPI(wheelCanvas, wheelCtx, 180, 180);
}
window.addEventListener('resize', resize);
resize();

// Off-screen canvas for gravitational field
fieldCanvas = document.createElement('canvas');
fieldCtx = fieldCanvas.getContext('2d');

// â•â•â• STABLE ALPHA HELPER (avoids invalid hex strings) â•â•â•
function rgba(color, alpha) {
  // Parse #RRGGBB to rgba
  const r = parseInt(color.slice(1,3), 16) || 0;
  const g = parseInt(color.slice(3,5), 16) || 0;
  const b = parseInt(color.slice(5,7), 16) || 0;
  return `rgba(${r},${g},${b},${Math.max(0, Math.min(1, alpha)).toFixed(3)})`;
}

// â•â•â• COORDINATE TRANSFORM (CSS pixel space, not canvas pixels) â•â•â•
function getCSSSize() {
  return { w: cosmos.width / DPR, h: cosmos.height / DPR };
}

function worldToScreen(wx, wy) {
  const {w, h} = getCSSSize();
  const cx = (w - 320) / 2;
  const cy = h / 2;
  const scale = Math.min(cx, cy) * zoom / 12;
  return [cx + wx * scale, cy - wy * scale];
}

function screenToWorld(sx, sy) {
  const {w, h} = getCSSSize();
  const cx = (w - 320) / 2;
  const cy = h / 2;
  const scale = Math.min(cx, cy) * zoom / 12;
  return [(sx - cx) / scale, -(sy - cy) / scale];
}

// â•â•â• DRAWING: GRAVITATIONAL FIELD â•â•â•
function drawField() {
  if (!showField) return;
  const {w: totalW, h} = getCSSSize();
  const w = totalW - 320;
  const gridSize = 50;
  const cellW = w / gridSize;
  const cellH = h / gridSize;

  for (let gx = 0; gx < gridSize; gx++) {
    for (let gy = 0; gy < gridSize; gy++) {
      const sx = gx * cellW + cellW / 2;
      const sy = gy * cellH + cellH / 2;
      const [wx, wy] = screenToWorld(sx, sy);

      let potential = 0;
      for (let i = 0; i < bodies.length; i++) {
        const b = bodies[i];
        const dx = wx - b.x;
        const dy = wy - b.y;
        const r = Math.sqrt(dx * dx + dy * dy);
        if (r > 0.05) {
          potential += b.mass / r;
        }
      }

      // Map potential to color intensity
      const intensity = Math.min(1, potential * 0.3);
      const r = Math.floor(40 + intensity * 60);
      const g = Math.floor(20 + intensity * 40);
      const b = Math.floor(60 + intensity * 80);
      ctx.fillStyle = `rgb(${r},${g},${b})`;
      ctx.fillRect(sx - cellW / 2, sy - cellH / 2, cellW + 1, cellH + 1);
    }
  }
}

// â•â•â• DRAWING: WAVEFRONTS â•â•â•
function drawWavefronts() {
  if (!showWaves) return;

  wavefronts.forEach(w => {
    w.radius += w.speed * speed;
    const [sx, sy] = worldToScreen(w.x, w.y);
    const {w: totalW, h: totalH} = getCSSSize();
    const scale = Math.min((totalW - 320) / 2, totalH / 2) * zoom / 12;
    const sr = w.radius * scale;
    const alpha = Math.max(0, 0.3 * (1 - w.radius / w.maxRadius));

    ctx.beginPath();
    ctx.arc(sx, sy, sr, 0, TAU);
    ctx.strokeStyle = rgba(w.color, alpha);
    ctx.lineWidth = 1;
    ctx.stroke();
  });
}

// â•â•â• DRAWING: TRAILS â•â•â•
function updateTrails() {
  for (let i = 1; i < bodies.length; i++) {
    const b = bodies[i];
    trails[i].push({ x: b.x, y: b.y });
    if (trails[i].length > 600) trails[i].shift();
  }
}

function drawTrails() {
  if (!showTrails) return;

  for (let i = 1; i < bodies.length; i++) {
    const trail = trails[i];
    if (trail.length < 2) continue;

    ctx.beginPath();
    const [sx0, sy0] = worldToScreen(trail[0].x, trail[0].y);
    ctx.moveTo(sx0, sy0);

    for (let j = 1; j < trail.length; j++) {
      const [sx, sy] = worldToScreen(trail[j].x, trail[j].y);
      ctx.lineTo(sx, sy);
    }

    const alpha = (i === selectedIdx) ? 0.6 : 0.2;
    ctx.strokeStyle = rgba(bodies[i].color, alpha);
    ctx.lineWidth = (i === selectedIdx) ? 1.5 : 0.7;
    ctx.stroke();
  }
}

// â•â•â• DRAWING: RESONANCE LINES â•â•â•
function drawResonanceLines() {
  if (!showResonance) return;
  const sel = bodies[selectedIdx];

  for (let i = 0; i < bodies.length; i++) {
    if (i === selectedIdx || i === 0) continue;
    const b = bodies[i];
    const res = hexResonance(sel.bin, b.bin);

    if (res > 0.95) { // only show significant resonances
      const [sx1, sy1] = worldToScreen(sel.x, sel.y);
      const [sx2, sy2] = worldToScreen(b.x, b.y);
      const alpha = (res - 0.82) * 2;

      ctx.beginPath();
      ctx.moveTo(sx1, sy1);
      ctx.lineTo(sx2, sy2);
      ctx.strokeStyle = `rgba(201,169,110,${alpha.toFixed(2)})`;
      ctx.lineWidth = (res - 0.82) * 8;
      ctx.stroke();

      // Resonance value at midpoint
      const mx = (sx1 + sx2) / 2, my = (sy1 + sy2) / 2;
      ctx.fillStyle = '#6a6a5a';
      ctx.font = '9px monospace';
      ctx.fillText(res.toFixed(3), mx + 4, my - 4);
    }
  }
}

// â•â•â• DRAWING: HEXAGRAM GLYPH â•â•â•
function drawHexGlyph(cx, cy, bin, size, color) {
  const lineH = size / 8;
  const lineW = size;
  const gap = lineH * 0.6;

  for (let line = 0; line < 6; line++) {
    const bit = (bin >> (5 - line)) & 1; // top line first visually
    const ly = cy - (2.5 - line) * (lineH + gap);

    ctx.fillStyle = color;
    if (bit) {
      // Yang: solid line
      ctx.fillRect(cx - lineW / 2, ly - lineH / 2, lineW, lineH);
    } else {
      // Yin: broken line
      const segW = lineW * 0.4;
      ctx.fillRect(cx - lineW / 2, ly - lineH / 2, segW, lineH);
      ctx.fillRect(cx + lineW / 2 - segW, ly - lineH / 2, segW, lineH);
    }
  }
}

// â•â•â• DRAWING: BODIES â•â•â•
function drawBodies() {
  for (let i = 0; i < bodies.length; i++) {
    const b = bodies[i];
    const [sx, sy] = worldToScreen(b.x, b.y);

    // Skip if off-screen
    const {w: cw, h: ch} = getCSSSize();
    if (sx < -50 || sx > cw || sy < -50 || sy > ch + 50) continue;

    // Glow
    const glowR = b.r * (i === 0 ? 3 : 1.8);
    const glow = ctx.createRadialGradient(sx, sy, 0, sx, sy, glowR);
    glow.addColorStop(0, rgba(b.color, 0.5));
    glow.addColorStop(1, rgba(b.color, 0));
    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.arc(sx, sy, glowR, 0, TAU);
    ctx.fill();

    // Body
    ctx.fillStyle = b.color;
    ctx.beginPath();
    ctx.arc(sx, sy, b.r, 0, TAU);
    ctx.fill();

    // Selection ring
    if (i === selectedIdx) {
      ctx.strokeStyle = '#c9a96e';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(sx, sy, b.r + 4, 0, TAU);
      ctx.stroke();
    }

    // Hexagram glyph (small, above the body)
    if (i > 0 && b.r >= 3) {
      drawHexGlyph(sx, sy - b.r - 18, b.bin, 14, rgba(b.color, 0.67));
    }

    // Name
    ctx.fillStyle = '#6a6a5a';
    ctx.font = '9px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(b.sym + ' ' + b.name, sx, sy + b.r + 14);
  }
}

// â•â•â• DRAWING: STARS â•â•â•
let stars = [];
function initStars() {
  for (let i = 0; i < 200; i++) {
    stars.push({
      x: Math.random() * 2000,
      y: Math.random() * 2000,
      r: Math.random() * 1.2,
      a: 0.2 + Math.random() * 0.5,
    });
  }
}

function drawStars() {
  const cw = cosmos.width / DPR;
  const ch = cosmos.height / DPR;
  stars.forEach(s => {
    // Slow, gentle pulse (not random flicker)
    const pulse = s.a + Math.sin(time * 2 + s.x * 0.01) * 0.08;
    ctx.fillStyle = `rgba(200,195,180,${Math.max(0.1, pulse).toFixed(3)})`;
    ctx.beginPath();
    ctx.arc(s.x % cw, s.y % ch, s.r, 0, TAU);
    ctx.fill();
  });
}

// â•â•â• PANEL: BODY INFO â•â•â•
function updatePanel() {
  const b = bodies[selectedIdx];
  const f = b.fourier;
  const e = b.energy;
  const lowerTri = TRI[(b.bin >> 3) & 7];
  const upperTri = TRI[b.bin & 7];

  // Hexagram lines HTML
  let linesHTML = '';
  for (let line = 5; line >= 0; line--) {
    const bit = (b.bin >> line) & 1;
    linesHTML += `<div class="hex-line ${bit ? 'yang' : 'yin'}"></div>`;
  }

  // Fourier bars
  let fourierHTML = '';
  if (f.harmonics) {
    f.harmonics.forEach((h, idx) => {
      const w = Math.min(100, (h.amp / (b.a || 1)) * 100);
      const hue = (h.phase / TAU) * 360;
      fourierHTML += `<div style="display:flex;align-items:center;gap:4px">
        <span style="color:#5a5a4a;width:16px">H${h.n}</span>
        <div class="fourier-bar" style="width:${w}%;background:hsl(${hue},60%,50%)"></div>
        <span style="color:#5a5a4a;font-size:9px">${h.amp.toFixed(3)}</span>
      </div>`;
    });
  }

  // Resonance with other bodies
  let resHTML = '';
  for (let i = 0; i < bodies.length; i++) {
    if (i === selectedIdx) continue;
    const res = hexResonance(b.bin, bodies[i].bin);
    const barW = ((res - 0.7) / 0.6) * 100;
    const barColor = res > 1.1 ? '#c9a96e' : res > 1.0 ? '#8a8a6a' : '#4a4a4a';
    resHTML += `<div style="display:flex;align-items:center;gap:4px;cursor:pointer" onclick="selectedIdx=${i};updatePanel()">
      <span style="color:${bodies[i].color};width:60px;font-size:9px">${bodies[i].sym} ${bodies[i].name}</span>
      <div style="flex:1;height:4px;background:#1a1a1a;border-radius:2px">
        <div style="width:${barW}%;height:100%;background:${barColor};border-radius:2px"></div>
      </div>
      <span style="color:#5a5a4a;font-size:9px">${res.toFixed(3)}</span>
    </div>`;
  }

  const r = Math.sqrt(b.x * b.x + b.y * b.y);
  const v = Math.sqrt(b.vx * b.vx + b.vy * b.vy);

  document.getElementById('body-info').innerHTML = `
    <div style="text-align:center;margin-bottom:8px">
      <span style="font-size:20px;color:${b.color}">${b.sym}</span>
      <span style="font-size:16px;color:#e0d8c8;margin-left:8px">${b.name}</span>
    </div>

    <div class="hex-display">
      <div class="hex-lines">${linesHTML}</div>
      <div>
        <div class="hex-name">Hex ${b.kwn}: ${b.hexName}</div>
        <div class="hex-number">${upperTri.sym} ${upperTri.name} over ${lowerTri.sym} ${lowerTri.name}</div>
        <div class="hex-number" style="margin-top:2px">${b.desc}</div>
        <div class="hex-number">Binary: ${b.bin.toString(2).padStart(6,'0')} (Fu Xi: ${b.bin})</div>
      </div>
    </div>

    <h3>&#9651; Fourier Coordinates</h3>
    <div class="stat-row"><span class="stat-label">&nu; frequency</span><span class="stat-value">${f.nu.toFixed(4)} yr&#x207B;&sup1;</span></div>
    <div class="stat-row"><span class="stat-label">A amplitude</span><span class="stat-value">${f.amp.toFixed(4)} AU</span></div>
    <div class="stat-row"><span class="stat-label">&phi; phase</span><span class="stat-value">${(f.phase * 180 / Math.PI).toFixed(1)}&deg; (${f.phase.toFixed(3)} rad)</span></div>

    <h3>&#9836; Harmonics (6 lines = 6 modes)</h3>
    ${fourierHTML}

    <h3>&#9889; Energy (E = mc&sup2; &times; 64)</h3>
    <div class="energy-section">
      <div class="stat-row"><span class="stat-label">Rest (mc&sup2;, c=64)</span><span class="stat-value">${e.hexagram.toExponential(3)}</span></div>
      <div class="stat-row"><span class="stat-label">Kinetic (&frac12;mv&sup2;)</span><span class="stat-value">${e.kinetic.toExponential(3)}</span></div>
      <div class="stat-row"><span class="stat-label">Potential</span><span class="stat-value">${e.potential.toExponential(3)}</span></div>
      <div class="energy-total">E = ${e.total.toExponential(4)}</div>
    </div>

    <h3>&#8634; Orbital State</h3>
    <div class="stat-row"><span class="stat-label">r (distance)</span><span class="stat-value">${r.toFixed(4)} AU</span></div>
    <div class="stat-row"><span class="stat-label">v (speed)</span><span class="stat-value">${v.toFixed(4)} AU/yr</span></div>
    <div class="stat-row"><span class="stat-label">L (ang. mom.)</span><span class="stat-value">${b.L.toFixed(6)}</span></div>
    <div class="stat-row"><span class="stat-label">&theta; (angle)</span><span class="stat-value">${(f.phase * 180 / Math.PI).toFixed(1)}&deg;</span></div>
    <div class="stat-row"><span class="stat-label">a (semi-major)</span><span class="stat-value">${b.a.toFixed(3)} AU</span></div>
    <div class="stat-row"><span class="stat-label">T (period)</span><span class="stat-value">${Math.pow(b.a || 1, 1.5).toFixed(3)} yr</span></div>

    <h3>&#9734; Hexagram Resonance</h3>
    ${resHTML}

    <h3 style="margin-top:16px;color:#4a4a3a;font-size:9px;text-align:center">
      t = ${time.toFixed(3)} yr &nbsp;|&nbsp; ${(time * 365.25).toFixed(1)} days
    </h3>
  `;
}

// â•â•â• KING WEN WHEEL â•â•â•
// Simplified: show positions of bodies on the 64-hexagram circle
const KING_WEN_ORDER = [
  1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,
  17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,
  33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,
  49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64
];

function drawWheel() {
  const w = 180; // CSS size (DPR handled by setTransform)
  const h = 180;
  const cx = w / 2, cy = h / 2;
  const r = 70;

  wheelCtx.clearRect(0, 0, w, h);

  // Background circle
  wheelCtx.strokeStyle = '#1a1a2a';
  wheelCtx.lineWidth = 1;
  wheelCtx.beginPath();
  wheelCtx.arc(cx, cy, r, 0, TAU);
  wheelCtx.stroke();

  // 64 tick marks
  for (let i = 0; i < 64; i++) {
    const angle = (i / 64) * TAU - Math.PI / 2;
    const inner = r - 4;
    const outer = r + 2;
    wheelCtx.strokeStyle = '#2a2a3a';
    wheelCtx.lineWidth = 0.5;
    wheelCtx.beginPath();
    wheelCtx.moveTo(cx + inner * Math.cos(angle), cy + inner * Math.sin(angle));
    wheelCtx.lineTo(cx + outer * Math.cos(angle), cy + outer * Math.sin(angle));
    wheelCtx.stroke();
  }

  // 8 trigram labels at octants
  const triLabels = ['â˜°','â˜±','â˜²','â˜³','â˜´','â˜µ','â˜¶','â˜·'];
  for (let i = 0; i < 8; i++) {
    const angle = (i / 8) * TAU - Math.PI / 2;
    const lr = r + 12;
    wheelCtx.fillStyle = '#4a4a3a';
    wheelCtx.font = '10px serif';
    wheelCtx.textAlign = 'center';
    wheelCtx.textBaseline = 'middle';
    wheelCtx.fillText(triLabels[i], cx + lr * Math.cos(angle), cy + lr * Math.sin(angle));
  }

  // Place bodies on the wheel based on their hexagram's King Wen position
  bodies.forEach((b, i) => {
    if (i === 0) {
      // Sun at center
      wheelCtx.fillStyle = b.color;
      wheelCtx.beginPath();
      wheelCtx.arc(cx, cy, 4, 0, TAU);
      wheelCtx.fill();
      return;
    }

    // Find King Wen position
    const kwIdx = KING_WEN_ORDER.indexOf(b.kwn);
    const angle = ((kwIdx >= 0 ? kwIdx : 0) / 64) * TAU - Math.PI / 2;

    // But also modulate by current orbital phase
    const phaseOffset = b.fourier.phase / TAU * (TAU / 64); // subtle phase modulation
    const finalAngle = angle + phaseOffset;

    const px = cx + (r - 14) * Math.cos(finalAngle);
    const py = cy + (r - 14) * Math.sin(finalAngle);

    wheelCtx.fillStyle = b.color;
    wheelCtx.beginPath();
    wheelCtx.arc(px, py, (i === selectedIdx) ? 4 : 2.5, 0, TAU);
    wheelCtx.fill();

    if (i === selectedIdx) {
      wheelCtx.strokeStyle = '#c9a96e';
      wheelCtx.lineWidth = 1;
      wheelCtx.beginPath();
      wheelCtx.arc(px, py, 6, 0, TAU);
      wheelCtx.stroke();
    }
  });

  // Center label
  wheelCtx.fillStyle = '#3a3a2a';
  wheelCtx.font = '7px monospace';
  wheelCtx.textAlign = 'center';
  wheelCtx.fillText('KING WEN', cx, cy + 14);
}

// â•â•â• CLICK TO SELECT â•â•â•
cosmos.addEventListener('click', (evt) => {
  const rect = cosmos.getBoundingClientRect();
  const mx = evt.clientX - rect.left;
  const my = evt.clientY - rect.top;

  let closest = -1, closestDist = Infinity;
  for (let i = 0; i < bodies.length; i++) {
    const [sx, sy] = worldToScreen(bodies[i].x, bodies[i].y);
    const d = Math.hypot(mx - sx, my - sy);
    if (d < Math.max(bodies[i].r + 10, 20) && d < closestDist) {
      closest = i;
      closestDist = d;
    }
  }

  if (closest >= 0) {
    selectedIdx = closest;
    updatePanel();
  }
});

// â•â•â• CONTROLS â•â•â•
document.getElementById('btn-pause').addEventListener('click', function() {
  paused = !paused;
  this.textContent = paused ? 'â–¶' : 'â¸';
  this.classList.toggle('active', paused);
});

document.getElementById('speed').addEventListener('input', function() {
  speed = parseFloat(this.value);
});

document.getElementById('zoom').addEventListener('input', function() {
  zoom = parseFloat(this.value);
});

document.getElementById('btn-field').addEventListener('click', function() {
  showField = !showField;
  this.classList.toggle('active', showField);
});

document.getElementById('btn-waves').addEventListener('click', function() {
  showWaves = !showWaves;
  this.classList.toggle('active', showWaves);
});

document.getElementById('btn-trails').addEventListener('click', function() {
  showTrails = !showTrails;
  this.classList.toggle('active', showTrails);
});

document.getElementById('btn-res').addEventListener('click', function() {
  showResonance = !showResonance;
  this.classList.toggle('active', showResonance);
});

// Mouse wheel zoom
cosmos.addEventListener('wheel', (evt) => {
  evt.preventDefault();
  zoom = Math.max(0.3, Math.min(15, zoom * (1 - evt.deltaY * 0.001)));
  document.getElementById('zoom').value = zoom;
});

// â•â•â• MAIN LOOP â•â•â•
let frameCount = 0;

function animate() {
  // Clear (CSS dimensions â€” DPR handled by setTransform)
  const {w: cssW, h: cssH} = getCSSSize();
  ctx.fillStyle = '#06060f';
  ctx.fillRect(0, 0, cssW, cssH);

  // Stars
  drawStars();

  if (!paused) {
    step();
    updateTrails();
    emitWaves();
  }

  updateFourier();
  updateEnergy();

  // Draw layers
  drawField();
  drawWavefronts();
  drawTrails();
  drawResonanceLines();
  drawBodies();

  // Update panel every 5 frames (performance)
  if (frameCount % 5 === 0) {
    updatePanel();
    drawWheel();
  }

  // Time display
  ctx.fillStyle = '#3a3a2a';
  ctx.font = '10px monospace';
  ctx.textAlign = 'left';
  ctx.fillText(`t = ${time.toFixed(2)} yr  |  ${(time * 365.25).toFixed(0)} days  |  E=mcÂ² Ã— 64  |  c=${C_HEX}`, 10, cssH - 8);

  frameCount++;
  requestAnimationFrame(animate);
}

// â•â•â• BOOT â•â•â•
initStars();
initBodies();
computeAccelerations();

// Set initial toggle states
document.getElementById('btn-waves').classList.add('active');
document.getElementById('btn-trails').classList.add('active');

animate();

</script>
</body>
</html>
