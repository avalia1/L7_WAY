/**
 * L7 Watermark — Content Attribution & Provenance System
 * Law XXXVIII — When asked directly, do not lie.
 * All autogenerated content is clearly labeled.
 * No pseudonyms. Clear attribution.
 *
 * Patent: Digital Content Provenance and Watermarking System
 * Inventor: Alberto Valido Delgado
 * Filed: 2026-03-01
 */

const fs = require('fs');
const path = require('path');
const crypto = require('crypto');
const os = require('os');

const L7_DIR = process.env.L7_DIR || path.join(process.env.HOME, '.l7');
const STATE_DIR = path.join(L7_DIR, 'state');
const REGISTRY_FILE = path.join(STATE_DIR, 'content-registry.json');

// Ensure state directory exists
if (!fs.existsSync(STATE_DIR)) {
  fs.mkdirSync(STATE_DIR, { recursive: true });
}

// ═══════════════════════════════════════════════════════════
// CREATOR — The immutable identity. No pseudonyms.
// ═══════════════════════════════════════════════════════════

const CREATOR = Object.freeze({
  name: 'Alberto Valido Delgado',
  system: 'L7',
  label: 'AUTOGENERATED',
  studio: 'L7 RESONANCE STUDIO',
  github: 'avalia1',
  copyright: `Alberto Valido Delgado ${new Date().getFullYear()}`,
  law: 'XXXVIII — When asked directly, do not lie.'
});

// ═══════════════════════════════════════════════════════════
// MACHINE SIGNATURE — Hardware identity
// ═══════════════════════════════════════════════════════════

/**
 * Get the machine signature for provenance tracking.
 * Combines hostname and a stable machine identifier.
 *
 * @returns {object} { hostname, uuid, signature }
 */
function getMachineSignature() {
  const hostname = os.hostname();

  // Derive a stable machine UUID from hostname + platform + arch + cpus
  // This avoids requiring system_profiler or elevated permissions
  const machineData = [
    hostname,
    os.platform(),
    os.arch(),
    os.cpus().length.toString(),
    os.cpus()[0]?.model || 'unknown'
  ].join('|');

  const uuid = crypto.createHash('sha256').update(machineData).digest('hex').slice(0, 32);
  const signature = `${hostname}:${uuid.slice(0, 12)}`;

  return Object.freeze({ hostname, uuid, signature });
}

const MACHINE = getMachineSignature();

// ═══════════════════════════════════════════════════════════
// TEXT WATERMARK
// ═══════════════════════════════════════════════════════════

/**
 * Watermark text content with attribution footer and integrity hash.
 *
 * Appends a metadata footer containing:
 *   - System identification
 *   - Creator (legal name, no pseudonyms)
 *   - ISO timestamp
 *   - SHA-256 content hash for integrity verification
 *   - Machine signature
 *
 * @param {string} content - The text content to watermark
 * @param {object} [metadata={}] - Additional metadata
 * @param {string} [metadata.source] - Source tool or module name
 * @param {string} [metadata.title] - Content title
 * @param {boolean} [metadata.register=true] - Whether to register in content registry
 * @returns {object} { watermarked, hash, uuid, registry_id }
 */
function watermarkText(content, metadata = {}) {
  if (typeof content !== 'string') {
    throw new Error('watermarkText requires a string');
  }

  const timestamp = new Date().toISOString();
  const hash = sha256(content);
  const contentUuid = generateUuid();

  const footer = [
    '',
    '---',
    `Generated by ${CREATOR.system} System | Creator: ${CREATOR.name} | ${timestamp} | ${CREATOR.label}`,
    `Content Hash: ${hash}`,
    `Machine: ${MACHINE.signature}`,
    `ID: ${contentUuid}`
  ].join('\n');

  const watermarked = content + footer;

  // Register in content registry
  let registryId = null;
  if (metadata.register !== false) {
    registryId = registerContent('text', hash, {
      uuid: contentUuid,
      source: metadata.source || 'unknown',
      title: metadata.title || null,
      length: content.length,
      timestamp
    });
  }

  return {
    watermarked,
    original: content,
    hash,
    uuid: contentUuid,
    registry_id: registryId,
    timestamp,
    machine: MACHINE.signature
  };
}

// ═══════════════════════════════════════════════════════════
// IMAGE / CANVAS WATERMARK
// ═══════════════════════════════════════════════════════════

/**
 * Draw a visible watermark on a Canvas 2D context.
 *
 * Renders a subtle gold watermark in the bottom-right corner:
 *   "L7 | Alberto Valido Delgado | AUTOGENERATED"
 * Semi-transparent (0.3 opacity), small font.
 *
 * Also embeds invisible steganographic data in the canvas pixel data
 * by encoding creator info in the LSBs of the red channel.
 *
 * @param {CanvasRenderingContext2D} ctx - The canvas 2D rendering context
 * @param {number} width - Canvas width in pixels
 * @param {number} height - Canvas height in pixels
 * @param {object} [options={}] - Options
 * @param {number} [options.opacity=0.3] - Watermark opacity (0-1)
 * @param {number} [options.fontSize=12] - Font size in pixels
 * @param {string} [options.color='#DAA520'] - Watermark color (default: goldenrod)
 * @param {boolean} [options.steganographic=true] - Embed invisible metadata
 * @param {boolean} [options.register=true] - Register in content registry
 * @returns {object} { hash, uuid, steganographic }
 */
function watermarkCanvas(ctx, width, height, options = {}) {
  const opacity = options.opacity ?? 0.3;
  const fontSize = options.fontSize ?? 12;
  const color = options.color || '#DAA520';
  const embedSteg = options.steganographic !== false;
  const timestamp = new Date().toISOString();

  // ─── Visible watermark ───
  const label = `${CREATOR.system} | ${CREATOR.name} | ${CREATOR.label}`;

  ctx.save();
  ctx.globalAlpha = opacity;
  ctx.font = `${fontSize}px monospace`;
  ctx.fillStyle = color;
  ctx.textAlign = 'right';
  ctx.textBaseline = 'bottom';

  // Bottom-right corner with padding
  const padding = fontSize;
  ctx.fillText(label, width - padding, height - padding);

  // Smaller timestamp line above
  ctx.font = `${Math.max(8, fontSize - 3)}px monospace`;
  ctx.fillText(timestamp, width - padding, height - padding - fontSize - 4);

  ctx.restore();

  // ─── Steganographic watermark (LSB encoding) ───
  let stegResult = null;
  if (embedSteg) {
    stegResult = embedSteganographic(ctx, width, height);
  }

  // ─── Integrity hash of canvas data ───
  const imageData = ctx.getImageData(0, 0, width, height);
  const hash = sha256(Buffer.from(imageData.data.buffer).toString('base64'));
  const contentUuid = generateUuid();

  // Register
  if (options.register !== false) {
    registerContent('image', hash, {
      uuid: contentUuid,
      source: options.source || 'canvas',
      width,
      height,
      steganographic: !!stegResult,
      timestamp
    });
  }

  return {
    hash,
    uuid: contentUuid,
    steganographic: !!stegResult,
    timestamp,
    machine: MACHINE.signature
  };
}

/**
 * Embed creator information steganographically in canvas pixel data.
 * Encodes the creator ID string into the least significant bits (LSBs)
 * of the red channel of pixel data.
 *
 * Format: [length_byte_hi, length_byte_lo, ...message_bytes]
 * Each byte uses 8 consecutive pixels (1 bit per pixel LSB).
 *
 * @param {CanvasRenderingContext2D} ctx - The canvas context
 * @param {number} width - Canvas width
 * @param {number} height - Canvas height
 * @returns {object} { embedded, bytes_used, capacity }
 */
function embedSteganographic(ctx, width, height) {
  const message = `L7:${CREATOR.name}:${CREATOR.label}:${new Date().toISOString()}`;
  const messageBytes = Buffer.from(message, 'utf8');

  const imageData = ctx.getImageData(0, 0, width, height);
  const pixels = imageData.data;
  const totalPixels = width * height;

  // Each byte needs 8 pixels (1 bit per pixel in red channel LSB)
  // First 2 bytes store message length
  const totalBytes = 2 + messageBytes.length;
  const pixelsNeeded = totalBytes * 8;

  if (pixelsNeeded > totalPixels) {
    return { embedded: false, reason: 'image too small', capacity: Math.floor(totalPixels / 8) - 2 };
  }

  // Encode length as 2 bytes (big-endian)
  const lengthBytes = Buffer.alloc(2);
  lengthBytes.writeUInt16BE(messageBytes.length, 0);

  const allBytes = Buffer.concat([lengthBytes, messageBytes]);

  // Write bits into red channel LSBs
  for (let byteIdx = 0; byteIdx < allBytes.length; byteIdx++) {
    const byte = allBytes[byteIdx];
    for (let bitIdx = 0; bitIdx < 8; bitIdx++) {
      const pixelIdx = (byteIdx * 8 + bitIdx) * 4; // RGBA stride
      const bit = (byte >> (7 - bitIdx)) & 1;
      // Clear LSB and set to our bit
      pixels[pixelIdx] = (pixels[pixelIdx] & 0xFE) | bit;
    }
  }

  ctx.putImageData(imageData, 0, 0);

  return {
    embedded: true,
    bytes_used: allBytes.length,
    pixels_used: pixelsNeeded,
    capacity: Math.floor(totalPixels / 8) - 2
  };
}

/**
 * Extract steganographic data from canvas pixel data.
 *
 * @param {CanvasRenderingContext2D} ctx - The canvas context
 * @param {number} width - Canvas width
 * @param {number} height - Canvas height
 * @returns {object} { found, message } or { found: false }
 */
function extractSteganographic(ctx, width, height) {
  const imageData = ctx.getImageData(0, 0, width, height);
  const pixels = imageData.data;

  // Read 2-byte length header
  const lengthBytes = readBytesFromLSB(pixels, 0, 2);
  const messageLength = (lengthBytes[0] << 8) | lengthBytes[1];

  if (messageLength <= 0 || messageLength > 10000) {
    return { found: false, reason: 'no valid steganographic header' };
  }

  const pixelsNeeded = (2 + messageLength) * 8;
  if (pixelsNeeded > width * height) {
    return { found: false, reason: 'claimed length exceeds image capacity' };
  }

  // Read message bytes
  const messageBytes = readBytesFromLSB(pixels, 2, messageLength);
  const message = Buffer.from(messageBytes).toString('utf8');

  // Validate it starts with the L7 prefix
  if (!message.startsWith('L7:')) {
    return { found: false, reason: 'no L7 steganographic marker' };
  }

  // Parse fields
  const parts = message.split(':');
  return {
    found: true,
    system: parts[0] || null,
    creator: parts[1] || null,
    label: parts[2] || null,
    timestamp: parts.slice(3).join(':') || null,
    raw: message
  };
}

/**
 * Read bytes from pixel red channel LSBs.
 *
 * @param {Uint8ClampedArray} pixels - RGBA pixel data
 * @param {number} byteOffset - Starting byte offset (not pixel offset)
 * @param {number} count - Number of bytes to read
 * @returns {number[]} Array of byte values
 */
function readBytesFromLSB(pixels, byteOffset, count) {
  const bytes = [];
  for (let byteIdx = 0; byteIdx < count; byteIdx++) {
    let byte = 0;
    for (let bitIdx = 0; bitIdx < 8; bitIdx++) {
      const pixelIdx = ((byteOffset + byteIdx) * 8 + bitIdx) * 4;
      const bit = pixels[pixelIdx] & 1;
      byte = (byte << 1) | bit;
    }
    bytes.push(byte);
  }
  return bytes;
}

// ═══════════════════════════════════════════════════════════
// VIDEO LABEL OVERLAY
// ═══════════════════════════════════════════════════════════

/**
 * Draw video overlay labels on a canvas context for a given frame.
 *
 * Per-frame rendering:
 *   - Top-left: "AUTOGENERATED"
 *   - Bottom-right: "Alberto Valido Delgado / L7 System"
 *   - Opening title card (first N frames): "Produced by L7 RESONANCE STUDIO"
 *   - Closing credits (last N frames): full attribution
 *   - Optional burn-in subtitle
 *
 * @param {CanvasRenderingContext2D} ctx - The canvas 2D context
 * @param {number} width - Frame width
 * @param {number} height - Frame height
 * @param {number} frame - Current frame number (0-indexed)
 * @param {object} [options={}] - Rendering options
 * @param {number} [options.totalFrames] - Total frames in video (needed for closing credits)
 * @param {number} [options.fps=30] - Frames per second
 * @param {number} [options.titleDuration=3] - Title card duration in seconds
 * @param {number} [options.creditDuration=4] - Closing credits duration in seconds
 * @param {string} [options.subtitle] - Burn-in subtitle text (e.g. song title)
 * @param {number} [options.fontSize=14] - Base font size
 * @param {string} [options.color='#FFFFFF'] - Text color
 * @param {number} [options.opacity=0.85] - Label opacity
 * @returns {object} { frame, phase, labels_drawn }
 */
function watermarkVideo(ctx, width, height, frame, options = {}) {
  const fps = options.fps || 30;
  const totalFrames = options.totalFrames || Infinity;
  const titleDuration = options.titleDuration ?? 3;
  const creditDuration = options.creditDuration ?? 4;
  const fontSize = options.fontSize || 14;
  const color = options.color || '#FFFFFF';
  const opacity = options.opacity ?? 0.85;
  const subtitle = options.subtitle || null;

  const titleFrames = titleDuration * fps;
  const creditFrames = creditDuration * fps;
  const creditStart = totalFrames - creditFrames;

  const labelsDrawn = [];
  let phase = 'body';

  ctx.save();
  ctx.globalAlpha = opacity;
  ctx.fillStyle = color;
  ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
  ctx.lineWidth = 2;

  // ─── Opening title card ───
  if (frame < titleFrames) {
    phase = 'title';
    const titleFade = frame < fps ? frame / fps : (frame > titleFrames - fps ? (titleFrames - frame) / fps : 1);
    ctx.save();
    ctx.globalAlpha = Math.min(opacity, titleFade);

    // "Produced by L7 RESONANCE STUDIO"
    ctx.font = `bold ${fontSize * 2}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    const titleText = `Produced by ${CREATOR.studio}`;
    drawTextWithShadow(ctx, titleText, width / 2, height / 2);
    labelsDrawn.push('title_card');

    ctx.restore();
  }

  // ─── Closing credits ───
  if (totalFrames !== Infinity && frame >= creditStart) {
    phase = 'credits';
    const creditFade = (frame - creditStart) / fps;
    ctx.save();
    ctx.globalAlpha = Math.min(opacity, creditFade);

    ctx.font = `bold ${fontSize * 1.5}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    const creditLine1 = `All content autogenerated | ${CREATOR.name} | ${new Date().getFullYear()}`;
    const creditLine2 = `${CREATOR.system} System`;
    drawTextWithShadow(ctx, creditLine1, width / 2, height / 2 - fontSize);
    drawTextWithShadow(ctx, creditLine2, width / 2, height / 2 + fontSize * 1.5);
    labelsDrawn.push('closing_credits');

    ctx.restore();
  }

  // ─── Persistent labels (always visible during body) ───
  ctx.font = `bold ${fontSize}px monospace`;

  // Top-left: AUTOGENERATED
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  drawTextWithShadow(ctx, CREATOR.label, fontSize, fontSize);
  labelsDrawn.push('autogenerated_label');

  // Bottom-right: Creator / System
  ctx.textAlign = 'right';
  ctx.textBaseline = 'bottom';
  const attribution = `${CREATOR.name} / ${CREATOR.system} System`;
  drawTextWithShadow(ctx, attribution, width - fontSize, height - fontSize);
  labelsDrawn.push('creator_label');

  // ─── Burn-in subtitle ───
  if (subtitle) {
    ctx.font = `${fontSize * 1.2}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    drawTextWithShadow(ctx, subtitle, width / 2, height - fontSize * 3);
    labelsDrawn.push('subtitle');
  }

  ctx.restore();

  return { frame, phase, labels_drawn: labelsDrawn };
}

/**
 * Draw text with a dark shadow/stroke for readability on any background.
 *
 * @param {CanvasRenderingContext2D} ctx - Canvas context
 * @param {string} text - Text to draw
 * @param {number} x - X position
 * @param {number} y - Y position
 */
function drawTextWithShadow(ctx, text, x, y) {
  // Dark shadow for contrast
  ctx.save();
  ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
  ctx.shadowBlur = 4;
  ctx.shadowOffsetX = 1;
  ctx.shadowOffsetY = 1;
  ctx.fillText(text, x, y);
  ctx.restore();
}

// ═══════════════════════════════════════════════════════════
// AUDIO WATERMARK
// ═══════════════════════════════════════════════════════════

/**
 * Add an inaudible ultrasonic watermark to an audio stream.
 *
 * Encodes the creator ID as a pattern of ultrasonic frequencies (>18kHz)
 * that are imperceptible to human hearing but can be detected and decoded.
 *
 * Encoding scheme:
 *   - Base frequency: 18500 Hz (above human hearing threshold)
 *   - Each byte of creator ID encoded as frequency offset: 18500 + (byte * 10) Hz
 *   - Each tone lasts 50ms with 10ms gaps
 *   - Pattern repeats every 30 seconds for redundancy
 *
 * Also returns ID3-style metadata tags for embedding in audio files.
 *
 * @param {AudioContext} audioContext - Web Audio API AudioContext
 * @param {AudioNode} destination - The destination node to connect to
 * @param {object} [options={}] - Options
 * @param {number} [options.baseFrequency=18500] - Base ultrasonic frequency in Hz
 * @param {number} [options.amplitude=0.01] - Watermark amplitude (very quiet)
 * @param {number} [options.toneDuration=0.05] - Duration of each tone in seconds
 * @param {number} [options.toneGap=0.01] - Gap between tones in seconds
 * @param {number} [options.repeatInterval=30] - Seconds between watermark repetitions
 * @param {boolean} [options.register=true] - Register in content registry
 * @returns {object} { node, metadata, stop(), uuid }
 */
function watermarkAudio(audioContext, destination, options = {}) {
  const baseFreq = options.baseFrequency || 18500;
  const amplitude = options.amplitude ?? 0.01;
  const toneDuration = options.toneDuration || 0.05;
  const toneGap = options.toneGap || 0.01;
  const repeatInterval = options.repeatInterval || 30;

  // Encode creator ID as byte sequence
  const creatorId = `L7:${CREATOR.name}`;
  const bytes = Buffer.from(creatorId, 'utf8');

  // Create a gain node to control watermark volume
  const gainNode = audioContext.createGain();
  gainNode.gain.value = amplitude;
  gainNode.connect(destination);

  let intervalId = null;
  let isActive = true;

  /**
   * Encode one full watermark burst.
   */
  function encodeBurst() {
    if (!isActive) return;

    const now = audioContext.currentTime;

    for (let i = 0; i < bytes.length; i++) {
      const freq = baseFreq + (bytes[i] * 10);
      const startTime = now + i * (toneDuration + toneGap);

      const osc = audioContext.createOscillator();
      osc.type = 'sine';
      osc.frequency.value = freq;
      osc.connect(gainNode);
      osc.start(startTime);
      osc.stop(startTime + toneDuration);
    }
  }

  // Initial burst
  encodeBurst();

  // Repeat periodically
  intervalId = setInterval(() => {
    if (isActive) encodeBurst();
  }, repeatInterval * 1000);

  // ID3-style metadata tags
  const metadata = Object.freeze({
    artist: CREATOR.name,
    album: `${CREATOR.system} ${CREATOR.label}`,
    comment: 'AI-assisted generation',
    copyright: CREATOR.copyright,
    encoder: `${CREATOR.system} Watermark System`,
    year: new Date().getFullYear().toString(),
    genre: 'AI Generated'
  });

  const contentUuid = generateUuid();

  // Register
  if (options.register !== false) {
    registerContent('audio', sha256(creatorId + Date.now()), {
      uuid: contentUuid,
      source: options.source || 'audio',
      base_frequency: baseFreq,
      timestamp: new Date().toISOString()
    });
  }

  return {
    node: gainNode,
    metadata,
    uuid: contentUuid,
    machine: MACHINE.signature,

    /**
     * Stop the ultrasonic watermark encoding.
     */
    stop() {
      isActive = false;
      if (intervalId) {
        clearInterval(intervalId);
        intervalId = null;
      }
      gainNode.disconnect();
    }
  };
}

/**
 * Generate ID3-style metadata tags for audio content.
 * Use this when you only need the metadata without the ultrasonic watermark
 * (e.g., for file export rather than real-time audio).
 *
 * @param {object} [extra={}] - Additional tag overrides
 * @returns {object} Frozen metadata tags object
 */
function getAudioMetadata(extra = {}) {
  return Object.freeze({
    artist: CREATOR.name,
    album: `${CREATOR.system} ${CREATOR.label}`,
    comment: 'AI-assisted generation',
    copyright: CREATOR.copyright,
    encoder: `${CREATOR.system} Watermark System`,
    year: new Date().getFullYear().toString(),
    genre: 'AI Generated',
    ...extra
  });
}

// ═══════════════════════════════════════════════════════════
// CONTENT REGISTRY
// ═══════════════════════════════════════════════════════════

/**
 * Register a piece of content in the provenance registry.
 *
 * Every piece of content produced by the L7 system gets an entry:
 *   - UUID
 *   - SHA-256 hash
 *   - Creator: Alberto Valido Delgado (always)
 *   - Timestamp
 *   - Type (text/image/video/audio)
 *   - Source tool/module
 *   - Machine signature
 *
 * @param {string} type - Content type: 'text' | 'image' | 'video' | 'audio'
 * @param {string} hash - SHA-256 hash of the content
 * @param {object} [metadata={}] - Additional metadata
 * @param {string} [metadata.uuid] - Pre-generated UUID (generated if not provided)
 * @param {string} [metadata.source] - Source tool or module
 * @param {string} [metadata.title] - Content title
 * @returns {string} The registry entry UUID
 */
function registerContent(type, hash, metadata = {}) {
  const validTypes = ['text', 'image', 'video', 'audio'];
  if (!validTypes.includes(type)) {
    throw new Error(`Invalid content type: ${type}. Must be one of: ${validTypes.join(', ')}`);
  }

  const registry = loadRegistry();
  const contentUuid = metadata.uuid || generateUuid();

  const entry = {
    uuid: contentUuid,
    hash,
    creator: CREATOR.name,
    system: CREATOR.system,
    type,
    source: metadata.source || 'unknown',
    title: metadata.title || null,
    timestamp: metadata.timestamp || new Date().toISOString(),
    machine: MACHINE.signature,
    verified: true
  };

  // Add any extra metadata fields (excluding reserved keys)
  const reserved = new Set(['uuid', 'hash', 'creator', 'system', 'type', 'source', 'title', 'timestamp', 'machine', 'verified']);
  for (const [key, value] of Object.entries(metadata)) {
    if (!reserved.has(key)) {
      entry[key] = value;
    }
  }

  registry.entries.push(entry);
  registry.count = registry.entries.length;
  registry.last_updated = new Date().toISOString();

  saveRegistry(registry);

  return contentUuid;
}

/**
 * Get the full content registry.
 *
 * @param {object} [filter={}] - Optional filters
 * @param {string} [filter.type] - Filter by content type
 * @param {string} [filter.source] - Filter by source module
 * @param {string} [filter.after] - Filter entries after this ISO timestamp
 * @param {string} [filter.before] - Filter entries before this ISO timestamp
 * @returns {object} { entries, count, last_updated }
 */
function getRegistry(filter = {}) {
  const registry = loadRegistry();
  let entries = registry.entries;

  if (filter.type) {
    entries = entries.filter(e => e.type === filter.type);
  }
  if (filter.source) {
    entries = entries.filter(e => e.source === filter.source);
  }
  if (filter.after) {
    entries = entries.filter(e => e.timestamp > filter.after);
  }
  if (filter.before) {
    entries = entries.filter(e => e.timestamp < filter.before);
  }

  return {
    entries,
    count: entries.length,
    total: registry.entries.length,
    last_updated: registry.last_updated
  };
}

// ═══════════════════════════════════════════════════════════
// VERIFICATION
// ═══════════════════════════════════════════════════════════

/**
 * Verify if content was produced by this L7 system.
 *
 * Checks:
 *   1. Watermark presence in the content
 *   2. Hash integrity (content matches its declared hash)
 *   3. Cross-reference with content registry
 *
 * @param {string|object} content - The content to verify (string for text, object for structured)
 * @param {string} type - Content type: 'text' | 'image' | 'audio'
 * @param {object} [options={}] - Verification options
 * @param {CanvasRenderingContext2D} [options.ctx] - Canvas context (for image verification)
 * @param {number} [options.width] - Image width (for steganographic check)
 * @param {number} [options.height] - Image height (for steganographic check)
 * @returns {object} Verification result { verified, checks, details }
 */
function verifyContent(content, type, options = {}) {
  const checks = {
    watermark_present: false,
    hash_valid: false,
    registry_match: false
  };
  const details = {};

  switch (type) {
    case 'text': {
      if (typeof content !== 'string') {
        return { verified: false, checks, details: { error: 'text content must be a string' } };
      }

      // Check for watermark footer
      const footerPattern = /^---\nGenerated by L7 System \| Creator: Alberto Valido Delgado \| .+ \| AUTOGENERATED$/m;
      checks.watermark_present = footerPattern.test(content);

      // Extract hash from footer
      const hashMatch = content.match(/Content Hash: ([a-f0-9]{64})/);
      if (hashMatch) {
        const declaredHash = hashMatch[1];
        details.declared_hash = declaredHash;

        // Extract original content (everything before the footer separator)
        const footerStart = content.lastIndexOf('\n---\nGenerated by L7 System');
        if (footerStart !== -1) {
          const originalContent = content.substring(0, footerStart);
          const computedHash = sha256(originalContent);
          checks.hash_valid = computedHash === declaredHash;
          details.computed_hash = computedHash;
        }

        // Cross-reference with registry
        const registry = loadRegistry();
        const match = registry.entries.find(e => e.hash === declaredHash);
        if (match) {
          checks.registry_match = true;
          details.registry_entry = {
            uuid: match.uuid,
            creator: match.creator,
            timestamp: match.timestamp,
            machine: match.machine
          };
        }
      }

      // Extract UUID from footer
      const uuidMatch = content.match(/ID: ([a-f0-9-]{36})/);
      if (uuidMatch) {
        details.content_uuid = uuidMatch[1];
      }

      break;
    }

    case 'image': {
      if (!options.ctx || !options.width || !options.height) {
        return { verified: false, checks, details: { error: 'image verification requires ctx, width, height' } };
      }

      // Check for steganographic watermark
      const steg = extractSteganographic(options.ctx, options.width, options.height);
      checks.watermark_present = steg.found;
      if (steg.found) {
        details.steganographic = steg;
        checks.hash_valid = steg.creator === CREATOR.name;
      }

      // Check registry by hash
      const imageData = options.ctx.getImageData(0, 0, options.width, options.height);
      const imageHash = sha256(Buffer.from(imageData.data.buffer).toString('base64'));
      const registry = loadRegistry();
      const match = registry.entries.find(e => e.hash === imageHash);
      if (match) {
        checks.registry_match = true;
        details.registry_entry = {
          uuid: match.uuid,
          creator: match.creator,
          timestamp: match.timestamp
        };
      }
      details.image_hash = imageHash;

      break;
    }

    case 'audio': {
      // Audio verification is limited without real-time analysis.
      // Check registry by provided hash or metadata.
      if (typeof content === 'object' && content.hash) {
        const registry = loadRegistry();
        const match = registry.entries.find(e => e.hash === content.hash);
        if (match) {
          checks.registry_match = true;
          checks.watermark_present = true;
          details.registry_entry = {
            uuid: match.uuid,
            creator: match.creator,
            timestamp: match.timestamp
          };
        }
      }

      // Check metadata tags
      if (typeof content === 'object' && content.metadata) {
        const meta = content.metadata;
        checks.hash_valid = meta.artist === CREATOR.name && meta.album?.includes(CREATOR.system);
        details.metadata_match = checks.hash_valid;
      }

      break;
    }

    default:
      return { verified: false, checks, details: { error: `unsupported type: ${type}` } };
  }

  const verified = checks.watermark_present && (checks.hash_valid || checks.registry_match);

  return {
    verified,
    confidence: verified ? (checks.hash_valid && checks.registry_match ? 'high' : 'medium') : 'none',
    creator: verified ? CREATOR.name : null,
    system: verified ? CREATOR.system : null,
    checks,
    details
  };
}

// ═══════════════════════════════════════════════════════════
// INTERNAL HELPERS
// ═══════════════════════════════════════════════════════════

/**
 * Compute SHA-256 hash of content.
 *
 * @param {string} content - Content to hash
 * @returns {string} Hex-encoded SHA-256 hash
 */
function sha256(content) {
  return crypto.createHash('sha256').update(content, 'utf8').digest('hex');
}

/**
 * Generate a UUID v4.
 *
 * @returns {string} UUID string
 */
function generateUuid() {
  const bytes = crypto.randomBytes(16);
  // Set version (4) and variant (RFC 4122)
  bytes[6] = (bytes[6] & 0x0f) | 0x40;
  bytes[8] = (bytes[8] & 0x3f) | 0x80;
  const hex = bytes.toString('hex');
  return [
    hex.slice(0, 8),
    hex.slice(8, 12),
    hex.slice(12, 16),
    hex.slice(16, 20),
    hex.slice(20, 32)
  ].join('-');
}

/**
 * Load the content registry from disk.
 *
 * @returns {object} Registry object { entries, count, last_updated }
 */
function loadRegistry() {
  if (!fs.existsSync(REGISTRY_FILE)) {
    return {
      version: 1,
      system: CREATOR.system,
      creator: CREATOR.name,
      entries: [],
      count: 0,
      created: new Date().toISOString(),
      last_updated: new Date().toISOString()
    };
  }
  try {
    return JSON.parse(fs.readFileSync(REGISTRY_FILE, 'utf8'));
  } catch {
    // Corrupted registry — start fresh but log the error
    console.error('[L7 Watermark] Registry corrupted, creating fresh registry');
    return {
      version: 1,
      system: CREATOR.system,
      creator: CREATOR.name,
      entries: [],
      count: 0,
      created: new Date().toISOString(),
      last_updated: new Date().toISOString(),
      _recovered_from_corruption: true
    };
  }
}

/**
 * Save the content registry to disk.
 *
 * @param {object} registry - The registry object to persist
 */
function saveRegistry(registry) {
  fs.writeFileSync(REGISTRY_FILE, JSON.stringify(registry, null, 2));
}

// ═══════════════════════════════════════════════════════════
// EXPORTS
// ═══════════════════════════════════════════════════════════

module.exports = {
  // Core watermarking functions
  watermarkText,
  watermarkCanvas,
  watermarkVideo,
  watermarkAudio,

  // Registry operations
  registerContent,
  getRegistry,

  // Verification
  verifyContent,

  // Steganographic helpers (exposed for direct image analysis)
  embedSteganographic,
  extractSteganographic,

  // Audio metadata helper
  getAudioMetadata,

  // Constants
  CREATOR,
  MACHINE
};
